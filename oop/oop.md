# OOP

## 객체지향 프로그래밍 (OOP)
### OOP
- object oriented programming
- 객체지향 프로그래밍
- 객체지향은 말 그대로 객체를 지향 하는 것
- 절차지향의 후발주자
- 객체지향은 생산성과 유지 보수 용이성을 높이는데 포커스를 두었음
### 객체
- 객체란 ? 프로그래밍에서 동작의 주체가 되는 요소
- 객체의 형태는 유/무형을 가리지 않음
- 실체가 명확 할 수도 무형의 개념일 수도 있음
- 모든 객체는 상태와 동작을 가짐
  ```text
    - 객체: class
    - 상태: 맴버 변수
    - 동작: 메소드
  ```
- 객체를 사용하려면 메모리에 할당해야하고, 이렇게 할당된 객체를 인스턴스라고함
### 객체지향 프로그래밍의 장점
- 코드의 재사용성
    - 모듈화된 객체를 기반으로 코드가 작성되기 때문에, 해당 객체의 특징을 비슷한 다른 로직에서도 적용하거나 사용해서 다른 개발자가 구현한 객체를 가져와 쓰기에 용이함
    - 개발 시간 단축
- 간편한 유지보수
    - 객체를 수정할 경우, 해당 객체를 사용하는 모든 로직에 일괄적으로 적용되니 중복코드에 대한 관리가 간단해짐
    - 동작이 변경될 경우, 해당 객체나 동작과 연관된 객체만을 찾아 수정하면 됨
- 큰 규모의 프로그래밍에 유리
    - 객체, 모듈 단위로 구분되는 특징으로 인해 업무 분장이 쉽고 각 모듈의 연관성을 도식하기 용이함
- 정확한 코딩
    - 구현 단위와 목표가 뚜렷해짐
    - 클래스는 오로지 관련 데이터만을 정의하기 때문에 한 클래스의 인스턴스가 수행될 떄 다른 프로그램의 데이터를 건들 수 없음. 높은 시스템 보안을 제공. 자료 훼손 방지
- 강한 응집력과 약한 결합력
    - 클래스 내 데이터(높은 응집력)
    - 클래스 간 독립성(약한 결합력)
### 객체지향 프로그래밍의 단점
- 비교적 느린 속도
    - 절차지향과 달리 객체지향은 각 객체의 의존 관계로 인해 대체적으로 속도가 느리다
- 높은 설계 역량 요구
    - 모듈 단위의 상호작용으로 이루어진 방식은, 모듈의 정확한 명세와 상호 간의 연관성이 얼마나 짜임새 있게 설계 되었는지 중요. 잘못 설계된 객체나 연관성은 스파게티 코드로 변하기 쉬움
- 코드의 잠재적인 복잡성
    - 높은 수준의 설계 역량 요구와 더불어 추상 객체, 상속, 인터페이스 등의 복잡한 개념과 그 활용은 코드의 구조를 파악하기 어렵게 만듦
---
## 객체지향 프로그래밍의 4가지 특징 
- 상속성(Inheritance)
    - 이미 정의된 상의 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
    - 여러 객체에서 사용되는 기능을 하나의 클래스로 분리해서 사용할 수 있도록록 위함. 중복되는 코드의 재사용성
- 추상화(Abstraction)
    - 여러 객체들의 공통적인 특징을 도출해 내는 것
- 캡슐화(Encapsulation)
    - 데이터(속성)와 데이터를 처리하는 함수로를 하나로 묶는 것
    - 코드를 재수정 없이 재활용
    - 정보은닉(Information Hiding)
        - 캡슐화에서 가장 중요한 개념
        - 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것
- 다형성 (Polymorphism)
    - 하나의 변수 또는 함수가 상황에 따라 다른 의미로 응답하는 것
    - 오버라이딩 / 오버로딩
        - 오버라이딩: 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용
        - 오버로딩: 같은 이름의 메서드를 여러개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술
    - 추상 메소드
        - 내용이 없는 매소드, 구현은 하지 않고 선언만 한 메소드
        - 추상 메소드로만 선언하고 상속 받은 자식 클래스에서 재정의하도록 할 때 사용
    - 추상 클래스
        - 하나 이상의 추상 메소드를 가지는 클래스
        - 일반적인 클래스는 세부적이고 구체적. 추상 클래스는 일반 클래스에 비해 구체적이지 않고 추상적
        - 선언만 되고 구현이 되지 않은 불완전한 메서드이므로 객체로 생성되어서는 안됨
        - 추상 클래스로 선언되면 객체 생성이 금지됨. 슈퍼 클래스로는 사용 가능
---
## OOP 5원칙 SOLID
- 올바른 객체 지향 설계를 위해 수립된 원칙
- 객체지향 5원칙이라고 명명
- 절대적은 아니지만 이 규칙을 준수한다면 올바른 객체지향 설계를 할 수 있음
### SOLID
- S 단일 책임원칙 (Single Responsiibility Principle)
    - 하나의 객체는 하나의 동작만의 책임을 갖는다
    - 책임 ? 개발에서는 이를 기능이라고 부름
    - 객체의 책임 의존성 과중을 최대한 지양하기 위한 원칙
    - 모듈화가 강해질 수록 의존/연관성이 줄어듦(반대로 모듈화가 약해질수록 다른 객체와의 의존/연관성은 크게 늘어남)
    - 응집도는 높고 결합도는 낮게
- O 개방-폐쇄의 원칙 (Open-Closed Principle)
    - 기능을 추가하더라도 기존 코드를 수정하지 않아야한다는 원칙
    - 객체의 확장은 개방적으로 객체의 수정은 폐쇄적으로 대하는 원칙
    - 기능 변경하거나 확장은 가능하지만(Open), 해당 기능의 코드는 수정하면 안된다는 뜻(Close)
    - 변경되는 것이 무엇인지에 초점을 두고 설계
- L 리스코프 치환의 법칙 (Liskov Subsitution Principle)
    - 상위 타입의 객체를 사용하다가 이를 상속 받은 하위 타입의 객체를 사용해도 사용 가능해야한다는 원칙
    - 자식 객체는 부모 객체의 가능한 행위를 수행할 수 있어야함
    - 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체 할 수 있다는 원칙
    - 리스코프 치환 원칙을 지키기 위해선 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요
    - 부모 객체의 오버라이딩은 주로 동일한 메소드를 자식 객체만의 동작을 추가하기 위해 한다는 걸 감안하면 매우 준수하기 까다로운 원칙
- I 인터페이스 분리의 원칙 (Interface Segregation Principle)
    - 하나의 인터페이스 보다는 여러개의 구체적인 인터페이스를 사용하는 것이 좋음
    - 클래스가 하나의 인터페이스를 구현하고 있을 때 하나의 거대한 인터페이스를 사용하는 것이 아니라 작은 단위의 인터페이스로 구현해야한다는 원칙
    - 객체가 반드시 필요한 기능만을 제한하는 원칙
    - 불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제거
    - 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야함
    - 자신이 구현하지 않는 인터페이스는 구현하지 않음
    - 하나의 일반적인 인터페이스 보다는 여러개의 구체적인 인터페이스가 나음
    - 객체를 상속할 땐 해당 객체가 상속받는 객체에 적합한 객체인지 의존적인 기능이 없는 지 판단하여 올바른 객체를 구현, 상속
- D 의존성 역전 원칙 (Dependency Inversion Principle)
    - 의존 → 어떤 다른 것을 가져다 쓰는것. 의존관계를 맺을 때는(다른 것을 끌어다 쓸 떄는) 보다 추상적인 것에 의존하는 것이 좋음
    - 객체는 저수준 모듈 보다 고수준 모듈에 의존해야한다는 원칙
        - 고수준 모듈: 인터페이스와 같은 객체의 형태나 추상적인 개념
        - 저수준 모듈: 실제 구현된 객체
    - 객체는 객체보다 인터페이스에 의존해야한다
    - 코드의 확장성 및 재사용성을 추구하기 위한 원칙